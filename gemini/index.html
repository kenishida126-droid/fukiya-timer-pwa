<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>スポーツ吹矢タイマー V46</title>
    <style>
        html, body {
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow-x: hidden;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #main-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 101vh;
            width: 100%;
        }

        #snap-point {
            scroll-snap-align: start;
            height: 2vh;
            width: 100%;
        }

        #header-container {
            width: 100%;
            text-align: center;
            flex-shrink: 0;
        }
        #title-main { display: inline-block; font-size: 9.5vw; font-weight: bold; line-height: 1.1; transform: scaleX(0.9); }
        #title-sub { display: block; font-family: sans-serif; font-size: 7vw; opacity: 0.9; margin-top: -0.5vh; }

        #timer-display {
            flex-shrink: 0;
            width: 100%;
            text-align: center;
            font-variant-numeric: tabular-nums;
            font-weight: 900;
            font-size: 40vw;
            line-height: 0.75;
            transform: scale(1.22, 1.5);
            transform-origin: center;
            margin-top: 5vh; 
            margin-bottom: 0;
            color: lime;
            cursor: pointer;
        }

        #circle-timer-container {
            flex-shrink: 0;
            width: 92vw;
            height: 92vw;
            margin-top: 8.5vh; 
            margin-bottom: 5vh;
            position: relative;
        }

        svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }
        
        .outline { fill: none; stroke: #fff; stroke-width: 1; }

        #mic-button { cursor: pointer; }
        #mic-circle { fill: #000; stroke: #fff; stroke-width: 2; }
        .mic-active #mic-icon-group { fill: #f00 !important; stroke: #f00 !important; filter: drop-shadow(0 0 5px #f00); }
        .mic-waiting #mic-icon-group { animation: mic-blink 1.2s infinite ease-in-out; }
        @keyframes mic-blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.2; } }
        #mic-icon-group { transform: rotate(90deg); transform-origin: 100px 100px; fill: #fff; stroke: #fff; }

        .blink { animation: sharp-blink-op 0.7s steps(1) infinite; }
        .blink-fast { animation: sharp-blink-op 0.2s steps(1) infinite; }
        @keyframes sharp-blink-op { 50% { opacity: 0; } }

        @keyframes rainbow-wave {
            0% { filter: brightness(0.5); }
            50% { filter: brightness(1.8) drop-shadow(0 0 10px white); }
            100% { filter: brightness(0.5); }
        }
        .wave-active path {
            animation: rainbow-wave 2s ease-in-out infinite;
        }
        .wave-active path:nth-child(1) { animation-delay: 0.0s; }
        .wave-active path:nth-child(2) { animation-delay: 0.2s; }
        .wave-active path:nth-child(3) { animation-delay: 0.4s; }
        .wave-active path:nth-child(4) { animation-delay: 0.6s; }
        .wave-active path:nth-child(5) { animation-delay: 0.8s; }
    </style>
</head>
<body>
    <div id="main-wrapper">
        <div id="snap-point"></div>
        
        <div id="header-container">
            <span id="title-main">スポーツ吹矢タイマー</span><br>
            <span id="title-sub">《by Ken.ishida & Gemini》</span>
        </div>

        <div id="timer-display" onclick="handleTap()">03:05</div>

        <div id="circle-timer-container">
            <svg viewBox="0 0 200 200">
                <g id="pie-segments"></g>
                <path id="mask-path" fill="#000" />
                <circle class="outline" cx="100" cy="100" r="98" />
                <g id="mic-button" onclick="toggleMic(event)">
                    <circle id="mic-circle" cx="100" cy="100" r="28" />
                    <g id="mic-icon-group">
                        <path d="M100,81c-3.8,0-7,3.1-7,7v10c0,3.8,3.2,7,7,7s7-3.2,7-7V88C107,84.1,103.8,81,100,81z" stroke-width="0"/>
                        <path d="M113,99v4c0,7.1-5.8,13-13,13s-13-5.9-13-13v-4h2v4c0,6.1,4.9,11,11,11s11-4.9,11-11v-4H113z" stroke-width="0"/>
                        <path d="M100,116 v7 M92,123 h16" fill="none" stroke-width="2.5" stroke-linecap="round"/>
                    </g>
                </g>
            </svg>
        </div>
    </div>

    <script>
        let timeLeft = 185, timerInterval = null, isRunning = false, wakeLock = null, isMicEnabled = false, recognition = null;
        const display = document.getElementById('timer-display'), micButton = document.getElementById('mic-button');
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playTapSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        async function updateWakeLock() {
            if (!('wakeLock' in navigator)) return;
            const shouldBeActive = isMicEnabled || isRunning;
            if (shouldBeActive && wakeLock === null) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => { wakeLock = null; });
                } catch (err) {}
            } else if (!shouldBeActive && wakeLock !== null) {
                try {
                    await wakeLock.release();
                    wakeLock = null;
                } catch (err) {}
            }
        }

        function updateMicVisual() {
            if (!isMicEnabled) { micButton.classList.remove('mic-active', 'mic-waiting'); return; }
            micButton.classList.add('mic-active');
            if (!isRunning && (timeLeft === 185 || timeLeft === 0)) { micButton.classList.add('mic-waiting'); }
            else { micButton.classList.remove('mic-waiting'); }
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'ja-JP';
            recognition.continuous = true;
            recognition.interimResults = true;

            recognition.onresult = (event) => {
                let transcript = "";
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    transcript += event.results[i][0].transcript;
                }
                transcript = transcript.toLowerCase().trim();
                if (!isRunning && (timeLeft === 185 || timeLeft === 0)) {
                    if (/(開始|かいし|カイシ|スタート|すたーと|start|始め|はじめ|ハジメ)/.test(transcript)) {
                        if (timeLeft === 0) resetTimer();
                        startTimer();
                    }
                }
            };
            recognition.onstart = () => { updateMicVisual(); updateWakeLock(); };
            recognition.onend = () => { if (isMicEnabled && !isRunning) recognition.start(); updateMicVisual(); updateWakeLock(); };
            recognition.onerror = () => { if (isMicEnabled) setTimeout(() => recognition.start(), 300); };
        }

        function toggleMic(event) {
            event.stopPropagation();
            playTapSound();
            if (!recognition) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isMicEnabled = !isMicEnabled;
            if (isMicEnabled) { try { recognition.start(); } catch(e) {} } else { recognition.stop(); }
            updateMicVisual();
            updateWakeLock();
        }

        let audioFiles = null;
        let audioUnlocked = false;
        function unlockAudio(){
            if(audioUnlocked) return;
            if(!audioFiles){
                audioFiles = {
                    start: new Audio('start-0.mp3'),
                    halfMin: new Audio('30sec.mp3'),
                    end: new Audio('end.mp3')
                };
            }
            [audioFiles.start, audioFiles.halfMin, audioFiles.end].forEach(a=>{
                a.volume = 0;
                const p = a.play();
                if(p){
                    p.then(()=>{
                        a.pause();
                        a.currentTime = 0;
                    }).catch(()=>{});
                }
                a.volume = 1;
            });
            audioUnlocked = true;
        }
        function safePlay(a){
            try{
                a.pause();
                a.currentTime = 0;
                a.play().catch(()=>{});
            }catch(e){}
        }
        function playChime() { const now = audioCtx.currentTime; const p = (f, s, d) => { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = 'triangle'; o.frequency.setValueAtTime(f, s); g.gain.setValueAtTime(0.5, s); g.gain.exponentialRampToValueAtTime(0.01, s + d); o.connect(g); g.connect(audioCtx.destination); o.start(s); o.stop(s + d); }; p(659.25, now, 0.8); p(523.25, now + 0.4, 1.2); }
        
        function updateDisplay() {
            let m = Math.floor(timeLeft / 60), s = timeLeft % 60;
            display.innerText = `${m}:${s.toString().padStart(2, '0')}`;
            display.classList.remove('blink', 'blink-fast');
            const pieSegments = document.getElementById('pie-segments');
            const maskPath = document.getElementById('mask-path');

            if (timeLeft > 180 || timeLeft === 0) {
                display.style.color = "lime";
                if (timeLeft === 0) display.classList.add('blink-fast');
                maskPath.setAttribute("d", ""); 
                pieSegments.classList.add('wave-active');
            } else {
                display.style.color = (timeLeft > 30) ? "gold" : "red";
                if (timeLeft <= 30) display.classList.add('blink');
                pieSegments.classList.remove('wave-active');
                const angle = ((180 - Math.max(0, timeLeft)) / 180) * 360;
                maskPath.setAttribute("d", angle <= 0 ? "" : getPathData(0, Math.min(angle, 359.9)));
            }
            
            if ([141, 107, 73, 39].includes(timeLeft)) playChime();
            if (timeLeft === 181 && audioFiles) safePlay(audioFiles.start);
            if (timeLeft === 30 && audioFiles) safePlay(audioFiles.halfMin);
            if (timeLeft === 0) {
                if (audioFiles) safePlay(audioFiles.end);
                clearInterval(timerInterval); isRunning = false;
                updateWakeLock(); 
                if (isMicEnabled) setTimeout(() => { if (!isRunning && isMicEnabled) { try { recognition.start(); } catch(e){} updateMicVisual(); } }, 2000);
                updateMicVisual();
            }
        }

        function getPathData(s, e) { const r = Math.PI / 180; return `M 100 100 L ${100 + 98 * Math.cos(s * r)} ${100 + 98 * Math.sin(s * r)} A 98 98 0 ${e-s<=180?0:1} 1 ${100 + 98 * Math.cos(e * r)} ${100 + 98 * Math.sin(e * r)} Z`; }
        
        function initPie() { 
            const pie = document.getElementById('pie-segments'); pie.innerHTML = ''; let ang = 0;
            [{sec:39,c:'lime'},{sec:34,c:'purple'},{sec:34,c:'Blue'},{sec:34,c:'yellow'},{sec:39,c:'red'}].forEach(a => {
                const d = (a.sec/180)*360; const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
                p.setAttribute("d", getPathData(ang, ang + d)); p.setAttribute("fill", a.c); pie.appendChild(p); ang += d;
            });
        }

        function handleTap() { 
            unlockAudio();
            playTapSound();
            if (isRunning || timeLeft === 0) resetTimer(); else startTimer(); 
        }

        async function startTimer() { 
            if (isRunning) return; 

            // ★ 音声起動時も確実にAudio解放
            unlockAudio();
            if (audioCtx.state === 'suspended') {
                try { await audioCtx.resume(); } catch(e){}
            }

            isRunning = true; 
            if (isMicEnabled) { try { recognition.stop(); } catch(e){} } 
            updateWakeLock(); 
            timerInterval = setInterval(() => { 
                if (timeLeft > 0) { 
                    timeLeft--; 
                    updateDisplay(); 
                } 
            }, 1000); 
            updateMicVisual(); 
        }

        function resetTimer() { 
            clearInterval(timerInterval); isRunning = false; timeLeft = 185; 
            if (isMicEnabled) { try { recognition.start(); } catch(e){} } 
            initPie(); 
            updateDisplay();
            updateMicVisual(); 
            updateWakeLock(); 
        }

        initPie(); 
        updateDisplay();
    
    /* === 虹色リニアモーターカー（謙さん仕様修正版） === */
(function(){
  const svg = document.querySelector("#circle-timer-container svg");
  if(!svg) return;

  const NS = "http://www.w3.org/2000/svg";
  const cx = 100, cy = 100;

  const old = svg.querySelector("#linear-train");
  if(old) old.remove();

  const outline = svg.querySelector(".outline");
  const tubeWidth = 6;
  const tubeRadius = 98 - tubeWidth/2;
  outline.setAttribute("r", tubeRadius);
  outline.style.strokeWidth = tubeWidth;

  const R = tubeRadius;
  const totalDeg = 60;
  const cars = 7;
  const carDeg = totalDeg / cars;

  const baseColors = [
    "#ff0000","#ff7f00","#ffff00",
    "#00ff00","#00aaff","#0000ff","#8b00ff"
  ];

  let rotation = 89.999; // 12時直前から開始して先頭(red)を最初に出庫させる            // 12時基準
  let animId = null;
  let running = false;
  let stopRequested = false;
  let colorShift = 0;
  let lastTs = null;

  // const degPerSec = 30; // debug用速度/frame(60fps想定)=約30deg/sec
  const degPerSec = 180; // 本番用/ 2秒/周(360=1秒/周)

  const carState = [];

  const group = document.createElementNS(NS,"g");
  group.setAttribute("id","linear-train");
  group.style.display = "none";
  svg.appendChild(group);

  function polar(angle){
    const rad = (angle-90)*Math.PI/180;
    return {
      x: cx + R*Math.cos(rad),
      y: cy + R*Math.sin(rad)
    };
  }

  function normalize(a){
    return ((a % 360) + 360) % 360;
  }

  // 回転は常に正方向前提
  function crossedTwelve(prev, now){
    const p = normalize(prev - 90);
    const n = normalize(now  - 90);
    return p > n; // 90度を跨いだ
  }

  function draw(){
    group.innerHTML = "";

    for(let i=0;i<cars;i++){
      if(!carState[i].visible) continue;

      const start = -i*carDeg;
      const end   = start - carDeg;

      const p1 = polar(start);
      const p2 = polar(end);

      const path = document.createElementNS(NS,"path");
      path.setAttribute("d",
        `M ${p1.x} ${p1.y} A ${R} ${R} 0 0 0 ${p2.x} ${p2.y}`
      );
      path.setAttribute("fill","none");
      path.setAttribute("stroke-width", tubeWidth);
      path.setAttribute("stroke-linecap","butt");

      const colorIndex = (i + colorShift) % cars;
      path.setAttribute("stroke", baseColors[colorIndex]);

      group.appendChild(path);
    }
  }

  function animate(ts){
    if(!lastTs) lastTs = ts;
    const delta = (ts - lastTs) / 1000;
    lastTs = ts;

    const prevRotation = rotation;
    rotation += degPerSec * delta;

    const prevHead = prevRotation;
    const nowHead  = rotation;

    // 周回で色シフト（停止要求前のみ）
    // ★ 全車両が出揃うまでは色シフトしない
    if(crossedTwelve(prevHead, nowHead) && !stopRequested && carState.every(c=>c.visible)){
      colorShift = (colorShift + 1) % cars;
    }

    // 各車両の12時判定
    for(let i=0;i<cars;i++){
      const offset = i * carDeg;
      const prevAngle = prevRotation - offset;
      const nowAngle  = rotation - offset;

      // 出庫（停止要求前のみ）
      if(!carState[i].visible && !stopRequested){
        if(crossedTwelve(prevAngle, nowAngle)){
          carState[i].visible = true;
        }
      }

      // 入庫
      if(carState[i].visible && stopRequested){
        if(crossedTwelve(prevAngle, nowAngle)){
          carState[i].visible = false;
        }
      }
    }

    draw();

    group.setAttribute("transform",
      `rotate(${rotation} ${cx} ${cy})`
    );

    if(stopRequested && carState.every(c=>!c.visible)){
      cancelAnimationFrame(animId);
      animId = null;
      group.style.display = "none";
      running = false;
      stopRequested = false;
      return;
    }

    animId = requestAnimationFrame(animate);
  }

  function initCars(){
    carState.length = 0;
    for(let i=0;i<cars;i++){
      // 出庫時は全車両非表示から開始
      carState.push({ visible:false });
    }
  }


  const origStart = window.startTimer;
  const origReset = window.resetTimer;
  const origUpdateDisplay = window.updateDisplay;

  window.startTimer = function(){
    rotation = 89.999; // 12時直前から開始（redを最初に出庫させる）
    colorShift = 0;
    stopRequested = false;
    running = false;
    lastTs = null;
    group.style.display = "none";
    initCars();
    if(origStart) origStart.apply(this,arguments);
  }

  window.updateDisplay = function(){
    if(origUpdateDisplay) origUpdateDisplay.apply(this,arguments);

    // 3:00で即運行開始
    if(timeLeft === 180 && !running){
      group.style.display = "block";
      initCars();
      running = true;
      if(!animId) animId = requestAnimationFrame(animate);
    }

    // 0:00で入庫開始（即消さない）
    if(timeLeft === 0 && running){
      stopRequested = true;
    }
  }

  window.resetTimer = function(){
    cancelAnimationFrame(animId);
    animId = null;
    group.style.display = "none";
    running = false;
    stopRequested = false;
    lastTs = null;
    initCars();
    if(origReset) origReset.apply(this,arguments);
  }
})();
</script>
</body>
</html>
